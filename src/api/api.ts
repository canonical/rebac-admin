/**
 * Generated by orval v6.18.1 üç∫
 * Do not edit manually.
 * Canonical OpenFGA Administration Product Compatibility API
 * The following specification outlines the API required for the FGA administration frontend to interact with an OpenFGA instance through a products API. This is an evolving specification as reflected in the version number.

#### Changelog
| Version | Notes |
|---|---|
| **0.0.6** | Ensured compatibility with Orval Restful Client Generator. |
| **0.0.5** | Add filter parameter to top level collection `GET` requests. |
| **0.0.4** | Added pagination parameters to appropriate `GET` requests.<br />Changed a couple of `PUT`'s to `PATCH`'s to account for the possible subset returned from the paginated `GET`'s. |
| **0.0.3** | Added skeleton error responses for `400`, `401`, `404`, and `5XX` (`default`) |
| **0.0.2** | Added `GET /users/{id}/groups`<br />Added `GET /users/{id}roles`<br />Added `GET /users/{id}/entitlements`<br />Added `GET,PUT /groups/{id}/users`<br>Added `DELETE /groups/{id}/users/{userId}`<br />Added `GET /roles/{id}/entitlements`<br />Added `DELETE /roles/{id}/entitlements/{entitlementId}` |
| **0.0.1** | Initial dump |

 * OpenAPI spec version: 0.0.6
 */
import * as axios from 'axios';
import type {
  AxiosRequestConfig,
  AxiosResponse,
  AxiosError
} from 'axios'
import {
  useQuery,
  useMutation
} from '@tanstack/react-query'
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey
} from '@tanstack/react-query'
import type {
  GetAuthenticationProviders200Item,
  BadRequestResponse,
  UnauthorizedResponse,
  NotFoundResponse,
  DefaultResponse,
  GetAuthenticationProvidersParams,
  IdentityProvider,
  GetAuthenticationParams,
  User,
  GetUsersParams,
  Group,
  GetUsersIdGroupsParams,
  Role,
  GetUsersIdRolesParams,
  Entitlement,
  GetUsersIdEntitlementsParams,
  GetGroupsParams,
  GetGroupsIdUsersParams,
  GetRolesParams,
  GetRolesIdEntitlementsParams,
  GetEntitlements200OneItem,
  GetEntitlementsParams,
  Resource,
  GetResourcesParams
} from './api.schemas'


/**
 * @summary Returns the list of supported identity providers.
 */
export const getAuthenticationProviders = (
    params?: GetAuthenticationProvidersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAuthenticationProviders200Item[]>> => {
    
    return axios.default.get(
      `/authentication/providers`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetAuthenticationProvidersQueryKey = (params?: GetAuthenticationProvidersParams,) => {
    
    return [`/authentication/providers`, ...(params ? [params]: [])] as const;
    }
  

    
export const getGetAuthenticationProvidersQueryOptions = <TData = Awaited<ReturnType<typeof getAuthenticationProviders>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(params?: GetAuthenticationProvidersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAuthenticationProviders>>, TError, TData>, axios?: AxiosRequestConfig}
) => {
    
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthenticationProvidersQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthenticationProviders>>> = ({ signal }) => getAuthenticationProviders(params, { signal, ...axiosOptions });

      
    
      
      
   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAuthenticationProviders>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAuthenticationProvidersQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthenticationProviders>>>
export type GetAuthenticationProvidersQueryError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

/**
 * @summary Returns the list of supported identity providers.
 */
export const useGetAuthenticationProviders = <TData = Awaited<ReturnType<typeof getAuthenticationProviders>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(
 params?: GetAuthenticationProvidersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAuthenticationProviders>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAuthenticationProvidersQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary List authentication methods.
 */
export const getAuthentication = (
    params?: GetAuthenticationParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<IdentityProvider[]>> => {
    
    return axios.default.get(
      `/authentication`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetAuthenticationQueryKey = (params?: GetAuthenticationParams,) => {
    
    return [`/authentication`, ...(params ? [params]: [])] as const;
    }
  

    
export const getGetAuthenticationQueryOptions = <TData = Awaited<ReturnType<typeof getAuthentication>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(params?: GetAuthenticationParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAuthentication>>, TError, TData>, axios?: AxiosRequestConfig}
) => {
    
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthenticationQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthentication>>> = ({ signal }) => getAuthentication(params, { signal, ...axiosOptions });

      
    
      
      
   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAuthentication>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAuthenticationQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthentication>>>
export type GetAuthenticationQueryError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

/**
 * @summary List authentication methods.
 */
export const useGetAuthentication = <TData = Awaited<ReturnType<typeof getAuthentication>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(
 params?: GetAuthenticationParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAuthentication>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAuthenticationQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Register a new authentication method.
 */
export const postAuthentication = (
    identityProvider: IdentityProvider, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<IdentityProvider>> => {
    
    return axios.default.post(
      `/authentication`,
      identityProvider,options
    );
  }



export const getPostAuthenticationMutationOptions = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAuthentication>>, TError,{data: IdentityProvider}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postAuthentication>>, TError,{data: IdentityProvider}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAuthentication>>, {data: IdentityProvider}> = (props) => {
          const {data} = props ?? {};

          return  postAuthentication(data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type PostAuthenticationMutationResult = NonNullable<Awaited<ReturnType<typeof postAuthentication>>>
    export type PostAuthenticationMutationBody = IdentityProvider
    export type PostAuthenticationMutationError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

    /**
 * @summary Register a new authentication method.
 */
export const usePostAuthentication = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAuthentication>>, TError,{data: IdentityProvider}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getPostAuthenticationMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a single authentication method.
 */
export const getAuthenticationId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<IdentityProvider>> => {
    
    return axios.default.get(
      `/authentication/${id}`,options
    );
  }


export const getGetAuthenticationIdQueryKey = (id: string,) => {
    
    return [`/authentication/${id}`] as const;
    }
  

    
export const getGetAuthenticationIdQueryOptions = <TData = Awaited<ReturnType<typeof getAuthenticationId>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAuthenticationId>>, TError, TData>, axios?: AxiosRequestConfig}
) => {
    
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAuthenticationIdQueryKey(id);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAuthenticationId>>> = ({ signal }) => getAuthenticationId(id, { signal, ...axiosOptions });

      
    
      
      
   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAuthenticationId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAuthenticationIdQueryResult = NonNullable<Awaited<ReturnType<typeof getAuthenticationId>>>
export type GetAuthenticationIdQueryError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

/**
 * @summary Get a single authentication method.
 */
export const useGetAuthenticationId = <TData = Awaited<ReturnType<typeof getAuthenticationId>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAuthenticationId>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAuthenticationIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Update an authentication method.
 */
export const patchAuthenticationId = (
    id: string,
    identityProvider: IdentityProvider, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.patch(
      `/authentication/${id}`,
      identityProvider,options
    );
  }



export const getPatchAuthenticationIdMutationOptions = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchAuthenticationId>>, TError,{id: string;data: IdentityProvider}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchAuthenticationId>>, TError,{id: string;data: IdentityProvider}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchAuthenticationId>>, {id: string;data: IdentityProvider}> = (props) => {
          const {id,data} = props ?? {};

          return  patchAuthenticationId(id,data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type PatchAuthenticationIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchAuthenticationId>>>
    export type PatchAuthenticationIdMutationBody = IdentityProvider
    export type PatchAuthenticationIdMutationError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

    /**
 * @summary Update an authentication method.
 */
export const usePatchAuthenticationId = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchAuthenticationId>>, TError,{id: string;data: IdentityProvider}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getPatchAuthenticationIdMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Remove an authentication method.
 */
export const deleteAuthenticationId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.delete(
      `/authentication/${id}`,options
    );
  }



export const getDeleteAuthenticationIdMutationOptions = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAuthenticationId>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAuthenticationId>>, TError,{id: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAuthenticationId>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteAuthenticationId(id,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type DeleteAuthenticationIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAuthenticationId>>>
    
    export type DeleteAuthenticationIdMutationError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

    /**
 * @summary Remove an authentication method.
 */
export const useDeleteAuthenticationId = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAuthenticationId>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getDeleteAuthenticationIdMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get list of users.
 */
export const getUsers = (
    params?: GetUsersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User[]>> => {
    
    return axios.default.get(
      `/users`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetUsersQueryKey = (params?: GetUsersParams,) => {
    
    return [`/users`, ...(params ? [params]: [])] as const;
    }
  

    
export const getGetUsersQueryOptions = <TData = Awaited<ReturnType<typeof getUsers>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(params?: GetUsersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>, axios?: AxiosRequestConfig}
) => {
    
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({ signal }) => getUsers(params, { signal, ...axiosOptions });

      
    
      
      
   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>
export type GetUsersQueryError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

/**
 * @summary Get list of users.
 */
export const useGetUsers = <TData = Awaited<ReturnType<typeof getUsers>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(
 params?: GetUsersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUsersQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Add a local user
 */
export const postUsers = (
    user: User, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User>> => {
    
    return axios.default.post(
      `/users`,
      user,options
    );
  }



export const getPostUsersMutationOptions = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsers>>, TError,{data: User}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postUsers>>, TError,{data: User}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUsers>>, {data: User}> = (props) => {
          const {data} = props ?? {};

          return  postUsers(data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type PostUsersMutationResult = NonNullable<Awaited<ReturnType<typeof postUsers>>>
    export type PostUsersMutationBody = User
    export type PostUsersMutationError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

    /**
 * @summary Add a local user
 */
export const usePostUsers = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUsers>>, TError,{data: User}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getPostUsersMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a single user.
 */
export const getUsersId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User>> => {
    
    return axios.default.get(
      `/users/${id}`,options
    );
  }


export const getGetUsersIdQueryKey = (id: string,) => {
    
    return [`/users/${id}`] as const;
    }
  

    
export const getGetUsersIdQueryOptions = <TData = Awaited<ReturnType<typeof getUsersId>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsersId>>, TError, TData>, axios?: AxiosRequestConfig}
) => {
    
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersIdQueryKey(id);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersId>>> = ({ signal }) => getUsersId(id, { signal, ...axiosOptions });

      
    
      
      
   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsersIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersId>>>
export type GetUsersIdQueryError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

/**
 * @summary Get a single user.
 */
export const useGetUsersId = <TData = Awaited<ReturnType<typeof getUsersId>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsersId>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUsersIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Update a local user.
 */
export const patchUsersId = (
    id: string,
    user: User, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.patch(
      `/users/${id}`,
      user,options
    );
  }



export const getPatchUsersIdMutationOptions = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchUsersId>>, TError,{id: string;data: User}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchUsersId>>, TError,{id: string;data: User}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchUsersId>>, {id: string;data: User}> = (props) => {
          const {id,data} = props ?? {};

          return  patchUsersId(id,data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type PatchUsersIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchUsersId>>>
    export type PatchUsersIdMutationBody = User
    export type PatchUsersIdMutationError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

    /**
 * @summary Update a local user.
 */
export const usePatchUsersId = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchUsersId>>, TError,{id: string;data: User}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getPatchUsersIdMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Remove a local user.
 */
export const deleteUsersId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.delete(
      `/users/${id}`,options
    );
  }



export const getDeleteUsersIdMutationOptions = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUsersId>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUsersId>>, TError,{id: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUsersId>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteUsersId(id,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type DeleteUsersIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUsersId>>>
    
    export type DeleteUsersIdMutationError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

    /**
 * @summary Remove a local user.
 */
export const useDeleteUsersId = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUsersId>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getDeleteUsersIdMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary List groups the user is a member of.
 */
export const getUsersIdGroups = (
    id: string,
    params?: GetUsersIdGroupsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Group[]>> => {
    
    return axios.default.get(
      `/users/${id}/groups`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetUsersIdGroupsQueryKey = (id: string,
    params?: GetUsersIdGroupsParams,) => {
    
    return [`/users/${id}/groups`, ...(params ? [params]: [])] as const;
    }
  

    
export const getGetUsersIdGroupsQueryOptions = <TData = Awaited<ReturnType<typeof getUsersIdGroups>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(id: string,
    params?: GetUsersIdGroupsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsersIdGroups>>, TError, TData>, axios?: AxiosRequestConfig}
) => {
    
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersIdGroupsQueryKey(id,params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersIdGroups>>> = ({ signal }) => getUsersIdGroups(id,params, { signal, ...axiosOptions });

      
    
      
      
   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersIdGroups>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsersIdGroupsQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersIdGroups>>>
export type GetUsersIdGroupsQueryError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

/**
 * @summary List groups the user is a member of.
 */
export const useGetUsersIdGroups = <TData = Awaited<ReturnType<typeof getUsersIdGroups>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(
 id: string,
    params?: GetUsersIdGroupsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsersIdGroups>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUsersIdGroupsQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary List roles the user is a member of.
 */
export const getUsersIdRoles = (
    id: string,
    params?: GetUsersIdRolesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Role[]>> => {
    
    return axios.default.get(
      `/users/${id}/roles`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetUsersIdRolesQueryKey = (id: string,
    params?: GetUsersIdRolesParams,) => {
    
    return [`/users/${id}/roles`, ...(params ? [params]: [])] as const;
    }
  

    
export const getGetUsersIdRolesQueryOptions = <TData = Awaited<ReturnType<typeof getUsersIdRoles>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(id: string,
    params?: GetUsersIdRolesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsersIdRoles>>, TError, TData>, axios?: AxiosRequestConfig}
) => {
    
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersIdRolesQueryKey(id,params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersIdRoles>>> = ({ signal }) => getUsersIdRoles(id,params, { signal, ...axiosOptions });

      
    
      
      
   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersIdRoles>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsersIdRolesQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersIdRoles>>>
export type GetUsersIdRolesQueryError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

/**
 * @summary List roles the user is a member of.
 */
export const useGetUsersIdRoles = <TData = Awaited<ReturnType<typeof getUsersIdRoles>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(
 id: string,
    params?: GetUsersIdRolesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsersIdRoles>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUsersIdRolesQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary List entitlements the user is a member of.
 */
export const getUsersIdEntitlements = (
    id: string,
    params?: GetUsersIdEntitlementsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Entitlement[]>> => {
    
    return axios.default.get(
      `/users/${id}/entitlements`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetUsersIdEntitlementsQueryKey = (id: string,
    params?: GetUsersIdEntitlementsParams,) => {
    
    return [`/users/${id}/entitlements`, ...(params ? [params]: [])] as const;
    }
  

    
export const getGetUsersIdEntitlementsQueryOptions = <TData = Awaited<ReturnType<typeof getUsersIdEntitlements>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(id: string,
    params?: GetUsersIdEntitlementsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsersIdEntitlements>>, TError, TData>, axios?: AxiosRequestConfig}
) => {
    
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersIdEntitlementsQueryKey(id,params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersIdEntitlements>>> = ({ signal }) => getUsersIdEntitlements(id,params, { signal, ...axiosOptions });

      
    
      
      
   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersIdEntitlements>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsersIdEntitlementsQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersIdEntitlements>>>
export type GetUsersIdEntitlementsQueryError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

/**
 * @summary List entitlements the user is a member of.
 */
export const useGetUsersIdEntitlements = <TData = Awaited<ReturnType<typeof getUsersIdEntitlements>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(
 id: string,
    params?: GetUsersIdEntitlementsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUsersIdEntitlements>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUsersIdEntitlementsQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Get all groups
 */
export const getGroups = (
    params?: GetGroupsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Group[]>> => {
    
    return axios.default.get(
      `/groups`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetGroupsQueryKey = (params?: GetGroupsParams,) => {
    
    return [`/groups`, ...(params ? [params]: [])] as const;
    }
  

    
export const getGetGroupsQueryOptions = <TData = Awaited<ReturnType<typeof getGroups>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(params?: GetGroupsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getGroups>>, TError, TData>, axios?: AxiosRequestConfig}
) => {
    
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupsQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroups>>> = ({ signal }) => getGroups(params, { signal, ...axiosOptions });

      
    
      
      
   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGroups>>, TError, TData> & { queryKey: QueryKey }
}

export type GetGroupsQueryResult = NonNullable<Awaited<ReturnType<typeof getGroups>>>
export type GetGroupsQueryError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

/**
 * @summary Get all groups
 */
export const useGetGroups = <TData = Awaited<ReturnType<typeof getGroups>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(
 params?: GetGroupsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getGroups>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetGroupsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Create a new group
 */
export const postGroups = (
    group: Group, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Group>> => {
    
    return axios.default.post(
      `/groups`,
      group,options
    );
  }



export const getPostGroupsMutationOptions = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postGroups>>, TError,{data: Group}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postGroups>>, TError,{data: Group}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postGroups>>, {data: Group}> = (props) => {
          const {data} = props ?? {};

          return  postGroups(data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type PostGroupsMutationResult = NonNullable<Awaited<ReturnType<typeof postGroups>>>
    export type PostGroupsMutationBody = Group
    export type PostGroupsMutationError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

    /**
 * @summary Create a new group
 */
export const usePostGroups = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postGroups>>, TError,{data: Group}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getPostGroupsMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a single user.
 */
export const getGroupsId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Group>> => {
    
    return axios.default.get(
      `/groups/${id}`,options
    );
  }


export const getGetGroupsIdQueryKey = (id: string,) => {
    
    return [`/groups/${id}`] as const;
    }
  

    
export const getGetGroupsIdQueryOptions = <TData = Awaited<ReturnType<typeof getGroupsId>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getGroupsId>>, TError, TData>, axios?: AxiosRequestConfig}
) => {
    
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupsIdQueryKey(id);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroupsId>>> = ({ signal }) => getGroupsId(id, { signal, ...axiosOptions });

      
    
      
      
   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGroupsId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetGroupsIdQueryResult = NonNullable<Awaited<ReturnType<typeof getGroupsId>>>
export type GetGroupsIdQueryError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

/**
 * @summary Get a single user.
 */
export const useGetGroupsId = <TData = Awaited<ReturnType<typeof getGroupsId>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getGroupsId>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetGroupsIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Update a group.
 */
export const patchGroupsId = (
    id: string,
    group: Group, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.patch(
      `/groups/${id}`,
      group,options
    );
  }



export const getPatchGroupsIdMutationOptions = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchGroupsId>>, TError,{id: string;data: Group}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchGroupsId>>, TError,{id: string;data: Group}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchGroupsId>>, {id: string;data: Group}> = (props) => {
          const {id,data} = props ?? {};

          return  patchGroupsId(id,data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type PatchGroupsIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchGroupsId>>>
    export type PatchGroupsIdMutationBody = Group
    export type PatchGroupsIdMutationError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

    /**
 * @summary Update a group.
 */
export const usePatchGroupsId = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchGroupsId>>, TError,{id: string;data: Group}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getPatchGroupsIdMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Remove a group.
 */
export const deleteGroupsId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.delete(
      `/groups/${id}`,options
    );
  }



export const getDeleteGroupsIdMutationOptions = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGroupsId>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteGroupsId>>, TError,{id: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteGroupsId>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteGroupsId(id,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type DeleteGroupsIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteGroupsId>>>
    
    export type DeleteGroupsIdMutationError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

    /**
 * @summary Remove a group.
 */
export const useDeleteGroupsId = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGroupsId>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getDeleteGroupsIdMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get the users of a group
 */
export const getGroupsIdUsers = (
    id: string,
    params?: GetGroupsIdUsersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User[]>> => {
    
    return axios.default.get(
      `/groups/${id}/users`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetGroupsIdUsersQueryKey = (id: string,
    params?: GetGroupsIdUsersParams,) => {
    
    return [`/groups/${id}/users`, ...(params ? [params]: [])] as const;
    }
  

    
export const getGetGroupsIdUsersQueryOptions = <TData = Awaited<ReturnType<typeof getGroupsIdUsers>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(id: string,
    params?: GetGroupsIdUsersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getGroupsIdUsers>>, TError, TData>, axios?: AxiosRequestConfig}
) => {
    
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupsIdUsersQueryKey(id,params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroupsIdUsers>>> = ({ signal }) => getGroupsIdUsers(id,params, { signal, ...axiosOptions });

      
    
      
      
   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGroupsIdUsers>>, TError, TData> & { queryKey: QueryKey }
}

export type GetGroupsIdUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getGroupsIdUsers>>>
export type GetGroupsIdUsersQueryError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

/**
 * @summary Get the users of a group
 */
export const useGetGroupsIdUsers = <TData = Awaited<ReturnType<typeof getGroupsIdUsers>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(
 id: string,
    params?: GetGroupsIdUsersParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getGroupsIdUsers>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetGroupsIdUsersQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Update the list of a groups users.
 */
export const patchGroupsIdUsers = (
    id: string,
    user: User, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.patch(
      `/groups/${id}/users`,
      user,options
    );
  }



export const getPatchGroupsIdUsersMutationOptions = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchGroupsIdUsers>>, TError,{id: string;data: User}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchGroupsIdUsers>>, TError,{id: string;data: User}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchGroupsIdUsers>>, {id: string;data: User}> = (props) => {
          const {id,data} = props ?? {};

          return  patchGroupsIdUsers(id,data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type PatchGroupsIdUsersMutationResult = NonNullable<Awaited<ReturnType<typeof patchGroupsIdUsers>>>
    export type PatchGroupsIdUsersMutationBody = User
    export type PatchGroupsIdUsersMutationError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

    /**
 * @summary Update the list of a groups users.
 */
export const usePatchGroupsIdUsers = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchGroupsIdUsers>>, TError,{id: string;data: User}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getPatchGroupsIdUsersMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Remove a user from a group
 */
export const deleteGroupsIdUsersUserId = (
    id: string,
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.delete(
      `/groups/${id}/users/${userId}`,options
    );
  }



export const getDeleteGroupsIdUsersUserIdMutationOptions = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGroupsIdUsersUserId>>, TError,{id: string;userId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteGroupsIdUsersUserId>>, TError,{id: string;userId: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteGroupsIdUsersUserId>>, {id: string;userId: string}> = (props) => {
          const {id,userId} = props ?? {};

          return  deleteGroupsIdUsersUserId(id,userId,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type DeleteGroupsIdUsersUserIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteGroupsIdUsersUserId>>>
    
    export type DeleteGroupsIdUsersUserIdMutationError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

    /**
 * @summary Remove a user from a group
 */
export const useDeleteGroupsIdUsersUserId = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGroupsIdUsersUserId>>, TError,{id: string;userId: string}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getDeleteGroupsIdUsersUserIdMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get the list of roles.
 */
export const getRoles = (
    params?: GetRolesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Role[]>> => {
    
    return axios.default.get(
      `/roles`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetRolesQueryKey = (params?: GetRolesParams,) => {
    
    return [`/roles`, ...(params ? [params]: [])] as const;
    }
  

    
export const getGetRolesQueryOptions = <TData = Awaited<ReturnType<typeof getRoles>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(params?: GetRolesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRoles>>, TError, TData>, axios?: AxiosRequestConfig}
) => {
    
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolesQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoles>>> = ({ signal }) => getRoles(params, { signal, ...axiosOptions });

      
    
      
      
   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoles>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRolesQueryResult = NonNullable<Awaited<ReturnType<typeof getRoles>>>
export type GetRolesQueryError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

/**
 * @summary Get the list of roles.
 */
export const useGetRoles = <TData = Awaited<ReturnType<typeof getRoles>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(
 params?: GetRolesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRoles>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRolesQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Create a new role
 */
export const postRoles = (
    role: Role, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Role[]>> => {
    
    return axios.default.post(
      `/roles`,
      role,options
    );
  }



export const getPostRolesMutationOptions = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postRoles>>, TError,{data: Role}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postRoles>>, TError,{data: Role}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postRoles>>, {data: Role}> = (props) => {
          const {data} = props ?? {};

          return  postRoles(data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type PostRolesMutationResult = NonNullable<Awaited<ReturnType<typeof postRoles>>>
    export type PostRolesMutationBody = Role
    export type PostRolesMutationError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

    /**
 * @summary Create a new role
 */
export const usePostRoles = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postRoles>>, TError,{data: Role}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getPostRolesMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get a single role.
 */
export const getRolesId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Role>> => {
    
    return axios.default.get(
      `/roles/${id}`,options
    );
  }


export const getGetRolesIdQueryKey = (id: string,) => {
    
    return [`/roles/${id}`] as const;
    }
  

    
export const getGetRolesIdQueryOptions = <TData = Awaited<ReturnType<typeof getRolesId>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRolesId>>, TError, TData>, axios?: AxiosRequestConfig}
) => {
    
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolesIdQueryKey(id);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolesId>>> = ({ signal }) => getRolesId(id, { signal, ...axiosOptions });

      
    
      
      
   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRolesId>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRolesIdQueryResult = NonNullable<Awaited<ReturnType<typeof getRolesId>>>
export type GetRolesIdQueryError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

/**
 * @summary Get a single role.
 */
export const useGetRolesId = <TData = Awaited<ReturnType<typeof getRolesId>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRolesId>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRolesIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Update a role.
 */
export const patchRolesId = (
    id: string,
    role: Role, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.patch(
      `/roles/${id}`,
      role,options
    );
  }



export const getPatchRolesIdMutationOptions = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchRolesId>>, TError,{id: string;data: Role}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchRolesId>>, TError,{id: string;data: Role}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchRolesId>>, {id: string;data: Role}> = (props) => {
          const {id,data} = props ?? {};

          return  patchRolesId(id,data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type PatchRolesIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchRolesId>>>
    export type PatchRolesIdMutationBody = Role
    export type PatchRolesIdMutationError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

    /**
 * @summary Update a role.
 */
export const usePatchRolesId = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchRolesId>>, TError,{id: string;data: Role}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getPatchRolesIdMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Delete a role.
 */
export const deleteRolesId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.delete(
      `/roles/${id}`,options
    );
  }



export const getDeleteRolesIdMutationOptions = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRolesId>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteRolesId>>, TError,{id: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRolesId>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteRolesId(id,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type DeleteRolesIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRolesId>>>
    
    export type DeleteRolesIdMutationError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

    /**
 * @summary Delete a role.
 */
export const useDeleteRolesId = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRolesId>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getDeleteRolesIdMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get the entitlements of a role
 */
export const getRolesIdEntitlements = (
    id: string,
    params?: GetRolesIdEntitlementsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Entitlement[]>> => {
    
    return axios.default.get(
      `/roles/${id}/entitlements`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetRolesIdEntitlementsQueryKey = (id: string,
    params?: GetRolesIdEntitlementsParams,) => {
    
    return [`/roles/${id}/entitlements`, ...(params ? [params]: [])] as const;
    }
  

    
export const getGetRolesIdEntitlementsQueryOptions = <TData = Awaited<ReturnType<typeof getRolesIdEntitlements>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(id: string,
    params?: GetRolesIdEntitlementsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRolesIdEntitlements>>, TError, TData>, axios?: AxiosRequestConfig}
) => {
    
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolesIdEntitlementsQueryKey(id,params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolesIdEntitlements>>> = ({ signal }) => getRolesIdEntitlements(id,params, { signal, ...axiosOptions });

      
    
      
      
   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRolesIdEntitlements>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRolesIdEntitlementsQueryResult = NonNullable<Awaited<ReturnType<typeof getRolesIdEntitlements>>>
export type GetRolesIdEntitlementsQueryError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

/**
 * @summary Get the entitlements of a role
 */
export const useGetRolesIdEntitlements = <TData = Awaited<ReturnType<typeof getRolesIdEntitlements>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(
 id: string,
    params?: GetRolesIdEntitlementsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRolesIdEntitlements>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetRolesIdEntitlementsQueryOptions(id,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Remove an entitlement from a role
 */
export const deleteRolesIdEntitlementsEntitlementId = (
    id: string,
    entitlementId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.default.delete(
      `/roles/${id}/entitlements/${entitlementId}`,options
    );
  }



export const getDeleteRolesIdEntitlementsEntitlementIdMutationOptions = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRolesIdEntitlementsEntitlementId>>, TError,{id: string;entitlementId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteRolesIdEntitlementsEntitlementId>>, TError,{id: string;entitlementId: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRolesIdEntitlementsEntitlementId>>, {id: string;entitlementId: string}> = (props) => {
          const {id,entitlementId} = props ?? {};

          return  deleteRolesIdEntitlementsEntitlementId(id,entitlementId,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type DeleteRolesIdEntitlementsEntitlementIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRolesIdEntitlementsEntitlementId>>>
    
    export type DeleteRolesIdEntitlementsEntitlementIdMutationError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

    /**
 * @summary Remove an entitlement from a role
 */
export const useDeleteRolesIdEntitlementsEntitlementId = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRolesIdEntitlementsEntitlementId>>, TError,{id: string;entitlementId: string}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getDeleteRolesIdEntitlementsEntitlementIdMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * The text/plain response type will return the raw authorisation model.
 * @summary Get the list of entitlements.
 */
export const getEntitlements = (
    params?: GetEntitlementsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetEntitlements200OneItem[] | string>> => {
    
    return axios.default.get(
      `/entitlements`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetEntitlementsQueryKey = (params?: GetEntitlementsParams,) => {
    
    return [`/entitlements`, ...(params ? [params]: [])] as const;
    }
  

    
export const getGetEntitlementsQueryOptions = <TData = Awaited<ReturnType<typeof getEntitlements>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(params?: GetEntitlementsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getEntitlements>>, TError, TData>, axios?: AxiosRequestConfig}
) => {
    
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEntitlementsQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEntitlements>>> = ({ signal }) => getEntitlements(params, { signal, ...axiosOptions });

      
    
      
      
   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEntitlements>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEntitlementsQueryResult = NonNullable<Awaited<ReturnType<typeof getEntitlements>>>
export type GetEntitlementsQueryError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

/**
 * @summary Get the list of entitlements.
 */
export const useGetEntitlements = <TData = Awaited<ReturnType<typeof getEntitlements>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(
 params?: GetEntitlementsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getEntitlements>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetEntitlementsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


/**
 * @summary Update the authorisation model.
 */
export const putEntitlements = (
    putEntitlementsBody: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    
    return axios.default.put(
      `/entitlements`,
      putEntitlementsBody,options
    );
  }



export const getPutEntitlementsMutationOptions = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putEntitlements>>, TError,{data: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof putEntitlements>>, TError,{data: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putEntitlements>>, {data: string}> = (props) => {
          const {data} = props ?? {};

          return  putEntitlements(data,axiosOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type PutEntitlementsMutationResult = NonNullable<Awaited<ReturnType<typeof putEntitlements>>>
    export type PutEntitlementsMutationBody = string
    export type PutEntitlementsMutationError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

    /**
 * @summary Update the authorisation model.
 */
export const usePutEntitlements = <TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putEntitlements>>, TError,{data: string}, TContext>, axios?: AxiosRequestConfig}
) => {
    
      const mutationOptions = getPutEntitlementsMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get the list of available resources.
 */
export const getResources = (
    params?: GetResourcesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Resource[]>> => {
    
    return axios.default.get(
      `/resources`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetResourcesQueryKey = (params?: GetResourcesParams,) => {
    
    return [`/resources`, ...(params ? [params]: [])] as const;
    }
  

    
export const getGetResourcesQueryOptions = <TData = Awaited<ReturnType<typeof getResources>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(params?: GetResourcesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getResources>>, TError, TData>, axios?: AxiosRequestConfig}
) => {
    
const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetResourcesQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof getResources>>> = ({ signal }) => getResources(params, { signal, ...axiosOptions });

      
    
      
      
   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getResources>>, TError, TData> & { queryKey: QueryKey }
}

export type GetResourcesQueryResult = NonNullable<Awaited<ReturnType<typeof getResources>>>
export type GetResourcesQueryError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>

/**
 * @summary Get the list of available resources.
 */
export const useGetResources = <TData = Awaited<ReturnType<typeof getResources>>, TError = AxiosError<BadRequestResponse | UnauthorizedResponse | NotFoundResponse | DefaultResponse>>(
 params?: GetResourcesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getResources>>, TError, TData>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetResourcesQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


